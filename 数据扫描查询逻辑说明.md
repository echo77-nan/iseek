# 数据扫描和查询逻辑说明

## 一、整体架构流程

```
用户输入扫描路径 
  ↓
前端发送扫描请求 (POST /api/scan)
  ↓
后端启动后台扫描任务
  ↓
清理旧记录 → 扫描文件系统 → 保存到数据库
  ↓
前端自动过滤显示
```

## 二、扫描流程详解

### 2.1 扫描请求处理 (`main.py`)

**入口：** `POST /api/scan?path=/path/to/scan&recursive=true`

```python
@app.post("/api/scan")
async def scan_directory(path, recursive, background_tasks):
    # 1. 立即返回响应，不阻塞
    background_tasks.add_task(scan_and_save_files, path, recursive)
    return {"success": True, "status": "processing"}
```

**特点：**
- ✅ 异步后台任务，立即返回响应
- ✅ 不阻塞 API 请求
- ✅ 适合扫描大量文件

### 2.2 扫描执行流程 (`scan_and_save_files`)

#### 步骤 1: 路径规范化
```python
from pathlib import Path
scan_path = str(Path(path).resolve())  # 转换为绝对路径
# 例如: "/home/echo.ln/nltk_data" → "/home/echo.ln/nltk_data"
```

#### 步骤 2: 清理旧记录 ⚠️ **关键步骤**
```python
deleted_count = db.delete_files_by_path_prefix(scan_path)
```

**作用：**
- 删除该路径下所有历史扫描记录
- 避免重复显示历史文件
- 确保只显示本次扫描的结果

**SQL 逻辑：**
```sql
DELETE FROM files 
WHERE file_path LIKE '/home/echo.ln/nltk_data/%' 
   OR file_path = '/home/echo.ln/nltk_data'
```

#### 步骤 3: 扫描文件系统
```python
scanner = FileScanner(max_file_size=104857600)  # 100MB
files = scanner.scan_directory(scan_path, recursive=True)
```

**扫描内容：**
- 文件路径、文件名
- 文件大小、类型、扩展名
- MIME 类型
- 创建时间、修改时间
- 文件哈希（小于 10MB 的文件）
- 元数据（是否符号链接、是否可读）

#### 步骤 4: 分批保存到数据库
```python
batch_size = 100
for i in range(0, len(files), batch_size):
    batch = files[i:i + batch_size]
    batch_saved = db.insert_files_batch(batch)
```

**批量处理优势：**
- 避免一次性插入过多数据
- 提高插入效率
- 减少数据库连接压力

## 三、数据存储逻辑

### 3.1 数据清理和验证 (`_sanitize_file_info`)

**目的：** 确保数据符合数据库字段限制

| 字段 | 限制 | 处理方式 |
|------|------|----------|
| `file_path` | VARCHAR(2000) | 超过则截断 |
| `file_name` | VARCHAR(500) | 超过则截断 |
| `file_extension` | VARCHAR(50) | 移除前导点，超过则截断 |
| `mime_type` | VARCHAR(200) | 超过则截断 |
| `file_hash` | VARCHAR(64) | 超过则截断 |
| `metadata` | TEXT | JSON 序列化 |

### 3.2 插入/更新逻辑 (`insert_file`)

**策略：** 检查-更新/插入模式

```python
# 1. 检查文件是否已存在
SELECT id FROM files WHERE file_path = %s

# 2. 如果存在 → 更新
UPDATE files SET 
    file_name = %s,
    file_size = %s,
    file_type = %s,
    scan_time = NOW()  # 更新扫描时间
WHERE id = %s

# 3. 如果不存在 → 插入
INSERT INTO files (...) VALUES (...)
```

**关键点：**
- ✅ 保留原有 `id` 和 `created_time`
- ✅ 更新 `scan_time` 为当前时间
- ✅ 更新文件大小、类型等可能变化的字段

## 四、查询逻辑

### 4.1 查询接口 (`GET /api/files`)

**参数：**
- `file_type`: 文件类型过滤（可选）
- `path_prefix`: 路径前缀过滤（可选）
- `limit`: 返回数量限制（默认 100）
- `offset`: 偏移量（默认 0）

### 4.2 查询构建 (`get_all_files`)

**动态 SQL 构建：**

```python
conditions = []
params = []

# 1. 文件类型过滤
if file_type:
    conditions.append("file_type = %s")
    params.append(file_type)

# 2. 路径前缀过滤
if path_prefix:
    normalized_prefix = path_prefix.rstrip('/') + '/'
    conditions.append("(file_path LIKE %s OR file_path = %s)")
    params.append(f"{normalized_prefix}%")  # 例如: "/home/user/%"
    params.append(path_prefix.rstrip('/'))   # 例如: "/home/user"

# 3. 组合查询
where_clause = " AND ".join(conditions) if conditions else "1=1"
sql = f"SELECT * FROM files WHERE {where_clause} ORDER BY scan_time DESC LIMIT %s OFFSET %s"
```

**SQL 示例：**

```sql
-- 只按路径过滤
SELECT * FROM files 
WHERE (file_path LIKE '/home/echo.ln/nltk_data/%' OR file_path = '/home/echo.ln/nltk_data')
ORDER BY scan_time DESC 
LIMIT 100 OFFSET 0

-- 路径 + 类型过滤
SELECT * FROM files 
WHERE file_type = 'document' 
  AND (file_path LIKE '/home/echo.ln/nltk_data/%' OR file_path = '/home/echo.ln/nltk_data')
ORDER BY scan_time DESC 
LIMIT 100 OFFSET 0
```

## 五、前端显示逻辑

### 5.1 状态管理

```javascript
const [currentScanPath, setCurrentScanPath] = useState(null)  // 当前扫描路径
const [fileType, setFileType] = useState(null)                // 文件类型过滤
```

### 5.2 扫描后自动过滤

```javascript
const handleScan = async () => {
  const response = await scanDirectory(searchPath, true)
  if (response.success) {
    // 关键：设置当前扫描路径
    setCurrentScanPath(searchPath.trim())
    // 自动刷新文件列表
    loadFiles()
  }
}
```

### 5.3 查询触发

```javascript
useEffect(() => {
  loadFiles()  // fileType 或 currentScanPath 变化时自动查询
}, [fileType, currentScanPath])

const loadFiles = async () => {
  // 使用当前扫描路径作为路径前缀过滤
  const response = await getFiles(fileType, currentScanPath)
  setFiles(response.files || [])
}
```

## 六、数据流程图

```
┌─────────────────┐
│  用户输入路径   │
│ /home/user/docs │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ POST /api/scan  │
│ 启动后台任务    │
└────────┬────────┘
         │
         ▼
┌─────────────────────────┐
│ 1. 规范化路径           │
│ /home/user/docs         │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 2. 删除旧记录           │
│ DELETE WHERE path LIKE  │
│ '/home/user/docs/%'     │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 3. 扫描文件系统         │
│ 找到 33 个文件          │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 4. 分批插入数据库       │
│ INSERT 33 条记录        │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 5. 前端设置过滤路径     │
│ currentScanPath =       │
│ '/home/user/docs'       │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 6. 查询时自动过滤       │
│ WHERE path LIKE          │
│ '/home/user/docs/%'     │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 7. 显示结果             │
│ 只显示 33 个文件        │
└─────────────────────────┘
```

## 七、关键设计决策

### 7.1 为什么扫描前删除旧记录？

**问题：** 如果只更新/插入，历史扫描的文件仍会显示

**解决方案：** 扫描前删除该路径下的所有旧记录

**优点：**
- ✅ 确保只显示本次扫描的结果
- ✅ 避免历史文件干扰
- ✅ 数据更准确

**缺点：**
- ⚠️ 如果文件被删除，数据库中也会删除（符合预期）

### 7.2 为什么使用路径前缀过滤？

**问题：** 如何只显示特定目录下的文件？

**解决方案：** 使用 `LIKE` 查询路径前缀

**SQL：**
```sql
WHERE file_path LIKE '/home/user/docs/%' 
   OR file_path = '/home/user/docs'
```

**优点：**
- ✅ 支持递归扫描的子目录
- ✅ 精确匹配扫描路径
- ✅ 前端自动应用过滤

### 7.3 为什么使用异步后台任务？

**问题：** 扫描大量文件会阻塞 API 请求

**解决方案：** FastAPI 的 `BackgroundTasks`

**优点：**
- ✅ 立即返回响应
- ✅ 不超时
- ✅ 用户体验好

## 八、数据一致性保证

### 8.1 扫描时间更新

每次扫描都会更新 `scan_time`，用于：
- 排序（最新的在前）
- 识别最近扫描的文件
- 区分不同批次的扫描

### 8.2 路径唯一性

虽然数据库中没有唯一索引（OceanBase 限制），但通过：
- 扫描前删除旧记录
- 插入时检查是否存在
- 确保同一路径不会重复

## 九、性能优化

### 9.1 批量插入
- 每批 100 个文件
- 减少数据库交互次数
- 提高插入效率

### 9.2 索引使用
- `idx_file_path`: 加速路径查询
- `idx_file_type`: 加速类型过滤
- `idx_scan_time`: 加速排序

### 9.3 连接管理
- 自动重连机制
- 连接有效性检查
- 避免连接超时

## 十、使用示例

### 扫描特定目录
```bash
POST /api/scan?path=/home/echo.ln/nltk_data/corpora/stopwords&recursive=true
```

**执行流程：**
1. 删除 `/home/echo.ln/nltk_data/corpora/stopwords` 下的所有旧记录
2. 扫描该目录，找到 33 个文件
3. 插入 33 条新记录
4. 前端自动设置 `currentScanPath`
5. 查询时自动过滤，只显示这 33 个文件

### 查询文件列表
```bash
GET /api/files?path_prefix=/home/echo.ln/nltk_data/corpora/stopwords&file_type=document&limit=100&offset=0
```

**返回：** 只包含该路径下的文档类型文件

## 十一、总结

**核心逻辑：**
1. ✅ 扫描前清理旧记录
2. ✅ 扫描后保存新记录
3. ✅ 查询时自动路径过滤
4. ✅ 前端自动应用过滤条件

**数据流：**
```
扫描路径 → 清理旧数据 → 扫描文件 → 保存数据库 → 前端过滤 → 显示结果
```

**关键特性：**
- 🎯 精确显示本次扫描结果
- 🎯 支持路径和类型双重过滤
- 🎯 自动更新扫描时间
- 🎯 异步处理，不阻塞

